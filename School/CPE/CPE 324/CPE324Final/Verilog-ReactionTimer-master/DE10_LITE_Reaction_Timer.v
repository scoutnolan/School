
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE_Reaction_Timer(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


//wire [3:0] cnt_a;
//wire [3:0] cnt_b;
//wire [3:0] cnt_c;
//
//wire carry_a;
//wire carry_b;
//wire carry_c;
//
//wire khz_clk;
//clock_divider clk_div(MAX10_CLK1_50, khz_clk);
//
//bcd_counter ba(khz_clk, cnt_a, carry_a);
//bcd_decoder bda(cnt_a, 0, HEX0);
//
//bcd_counter bb(carry_a, cnt_b, carry_b);
//bcd_decoder bdb(cnt_b, 0, HEX1);
//
//bcd_counter bc(carry_b, cnt_c, carry_c);
//bcd_decoder bdc(cnt_c, 0, HEX2);

//assign LEDR[0] = 

//timing_state(khz_clk, KEY, {HEX2, HEX1, HEX0}, LEDR);


//finite_state_machine fsm(KEY, LEDR, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5);

//simple_machine sm(KEY, HEX5, HEX4, HEX3, LEDR, MAX10_CLK2_50);

//simple_machine_2 sm2(MAX10_CLK2_50, !KEY[1], KEY, LEDR, HEX0, HEX1);

assign HEX5 = 8'hff;
assign HEX4 = 8'hff;
assign HEX3 = 8'hff;
Project2_top(HEX0, HEX1, HEX2, LEDR, SW, KEY[0], KEY[1], MAX10_CLK1_50, MAX10_CLK2_50);

//wire khz_clk;
//clock_divider clk_div(MAX10_CLK2_50, khz_clk);
//
//wire [3:0] count_a;
//wire [3:0] count_b;
//wire [3:0] count_c;
//wire [3:0] count_d;
//wire [3:0] count_e;
//wire [3:0] count_f;
//
//wire carry_a;
//wire carry_b;
//wire carry_c;
//wire carry_d;
//wire carry_e;
//wire carry_f;
//
//bcd_counter ca(khz_clk, !KEY[0], count_a, carry_a);
//bcd_counter cb(carry_a, !KEY[0], count_b, carry_b);
//bcd_counter cc(carry_b, !KEY[0], count_c, carry_c);
//bcd_counter cd(carry_c, !KEY[0], count_d, carry_d);
//bcd_counter ce(carry_d, !KEY[0], count_e, carry_e);
//bcd_counter cf(carry_e, !KEY[0], count_f, carry_f);
//
//bcd_decoder da(count_a, 0, HEX0);
//bcd_decoder db(count_b, 0, HEX1);
//bcd_decoder dc(count_c, 0, HEX2);
//bcd_decoder dd(count_d, 1, HEX3);
//bcd_decoder de(count_e, 0, HEX4);
//bcd_decoder df(count_f, 0, HEX5);

//=======================================================
//  Structural coding
//=======================================================



endmodule
